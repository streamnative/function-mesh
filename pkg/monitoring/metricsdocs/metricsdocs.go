// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package main

import (
	"fmt"
	"sort"

	"github.com/streamnative/function-mesh/pkg/monitoring"
)

// please run "make generate-metricsdocs" to run this tool and update metrics documentation
const (
	title      = "# Operator Metrics\n"
	background = "This document aims to help users that are not familiar with metrics exposed by this operator.\n" +
		"The metrics documentation is auto-generated by the utility tool \"pkg/monitoring/metricsdocs\" and reflects all of the metrics that are exposed by the operator.\n\n"

	KVSpecificMetrics = "## Operator Metrics List\n"

	opening = title +
		background +
		KVSpecificMetrics

	// footer
	footerHeading = "## Developing new metrics\n"
	footerContent = "After developing new metrics or changing old ones, please run \"make generate-metricsdocs\" to regenerate this document.\n\n" +
		"If you feel that the new metric doesn't follow these rules, please change \"pkg/monitoring/metricsdocs\" according to your needs.\n"

	footer = footerHeading + footerContent
)

// TODO: scaffolding these helpers with operator-lib: https://github.com/operator-framework/operator-lib.

// metricList contains the name, description, and type for each metric.
func main() {
	metricList := metricDescriptionListToMetricList(monitoring.ListMetrics())
	sort.Sort(metricList)
	writeToStdOut(metricList)
}

// writeToStdOut receives a list of metrics and prints them to STDOUT.
func writeToStdOut(metricsList metricList) {
	fmt.Print(opening)
	metricsList.writeOut()
	fmt.Print(footer)
}

// Metric is an exported struct that defines the metric
// name, description, and type as a new type named Metric.
type Metric struct {
	name        string
	description string
	metricType  string
}

func metricDescriptionToMetric(md monitoring.MetricDescription) Metric {
	return Metric{
		name:        md.Name,
		description: md.Help,
		metricType:  md.Type,
	}
}

// writeOut receives a metric of type metric and prints
// the metric name, description, and type.
func (m Metric) writeOut() {
	fmt.Println("###", m.name)
	fmt.Println(m.description, "Type: "+m.metricType+".")
}

// metricList is an array that contain metrics from type metric,
// as a new type named metricList.
type metricList []Metric

// metricDescriptionListToMetricList collects the metrics exposed by the
// operator, and inserts them into the metricList array.
func metricDescriptionListToMetricList(mdl []monitoring.MetricDescription) metricList {
	res := make([]Metric, len(mdl))
	for i, md := range mdl {
		res[i] = metricDescriptionToMetric(md)
	}

	return res
}

// Len implements sort.Interface.Len
func (m metricList) Len() int {
	return len(m)
}

// Less implements sort.Interface.Less
func (m metricList) Less(i, j int) bool {
	return m[i].name < m[j].name
}

// Swap implements sort.Interface.Swap
func (m metricList) Swap(i, j int) {
	m[i], m[j] = m[j], m[i]
}

func (m metricList) writeOut() {
	for _, met := range m {
		met.writeOut()
	}
}
